rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isValidUser(userId) {
      return isAuthenticated() && userId == resource.data.deviceId;
    }
    
    function isValidContent(content) {
      return content is string && content.size() > 0 && content.size() <= 200;
    }
    
    // Enhanced timestamp validation with proper type checking
    function isRecentTimestamp(ts) {
      return ts is timestamp && ts > request.time - duration.value(5, 'm');
    }
    
    // Validate user ID format: should be "uid_deviceId"
    function isValidUserIdFormat(userId, firebaseUid) {
      return userId is string && 
             userId.size() > 0 && 
             userId.size() <= 100 &&
             userId.matches(firebaseUid + '_.*');
    }
    
    // Validate required user fields
    function hasValidUserFields(data) {
      return data.keys().hasAll(['deviceId', 'firebaseUid', 'screenName', 'color', 'createdAt']) &&
             data.deviceId is string &&
             data.firebaseUid is string &&
             data.screenName is string &&
             data.color is map &&
             data.color.keys().hasAll(['name', 'value']);
    }
    
    // Validate required post fields
    function hasValidPostFields(data) {
      return data.keys().hasAll(['content', 'authorId', 'authorName', 'authorColor', 'createdAt']) &&
             data.content is string &&
             data.authorId is string &&
             data.authorName is string &&
             data.authorColor is map &&
             (data.location == null || data.location is latlng) &&
             (data.nearestCity == null || data.nearestCity is string);
    }
    
    // Users collection - device-based anonymous users
    match /users/{userId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() 
        && isValidUserIdFormat(userId, request.auth.uid)
        && userId == request.auth.uid + "_" + request.resource.data.deviceId
        && request.resource.data.firebaseUid == request.auth.uid
        && hasValidUserFields(request.resource.data)
        && isRecentTimestamp(request.resource.data.createdAt);
      allow update: if isAuthenticated() 
        && userId == request.auth.uid + "_" + resource.data.deviceId
        && request.resource.data.firebaseUid == resource.data.firebaseUid // Prevent changing Firebase UID
        && request.resource.data.deviceId == resource.data.deviceId; // Prevent changing device ID
    }
    
    // Posts collection
    match /posts/{postId} {
      allow read: if true; // Posts are public, but we filter by location client-side
      allow create: if isAuthenticated()
        && isValidContent(request.resource.data.content)
        && hasValidPostFields(request.resource.data)
        && isRecentTimestamp(request.resource.data.createdAt)
        && request.resource.data.upvotes == 0
        && request.resource.data.downvotes == 0
        && request.resource.data.score == 0
        && request.resource.data.commentsCount == 0
        && request.resource.data.reportsCount == 0;
      // Allow updates for vote counts and comment counts
      allow update: if isAuthenticated()
        && request.resource.data.content == resource.data.content // Content cannot be changed
        && request.resource.data.authorId == resource.data.authorId // Author cannot be changed
        && request.resource.data.authorName == resource.data.authorName // Author name cannot be changed
        && request.resource.data.createdAt == resource.data.createdAt // Creation time cannot be changed
        && (
          // Allow vote count updates
          (request.resource.data.keys().hasOnly(['content', 'authorId', 'authorName', 'authorColor', 'location', 'nearestCity', 'upvotes', 'downvotes', 'score', 'commentsCount', 'reportsCount', 'createdAt'])
           && request.resource.data.upvotes is int
           && request.resource.data.downvotes is int
           && request.resource.data.score is int
           && request.resource.data.commentsCount is int
           && request.resource.data.reportsCount is int)
        );
    }
    
    // Comments collection
    match /comments/{commentId} {
      allow read: if true; // Comments are public
      allow create: if isAuthenticated()
        && isValidContent(request.resource.data.content)
        && isRecentTimestamp(request.resource.data.createdAt)
        && request.resource.data.postId is string
        && request.resource.data.authorId is string
        && request.resource.data.authorName is string
        && request.resource.data.authorColor is map;
      allow update, delete: if false; // Comments are immutable
    }
    
    // Votes collection
    match /votes/{voteId} {
      allow read: if isAuthenticated(); // Users can read votes to see their own voting history
      allow write: if isAuthenticated()
        && voteId.matches('.*_.*') // Must follow userId_postId pattern
        && request.resource.data.userId is string
        && request.resource.data.postId is string
        && request.resource.data.type in ['upvote', 'downvote']
        && isRecentTimestamp(request.resource.data.createdAt);
    }
    
    // Reports collection
    match /reports/{reportId} {
      allow read: if false; // Only admins should read reports (handled server-side)
      allow create: if isAuthenticated()
        && request.resource.data.postId is string
        && request.resource.data.userId is string
        && request.resource.data.reason is string
        && request.resource.data.reason.size() > 0
        && request.resource.data.reason.size() <= 500
        && isRecentTimestamp(request.resource.data.createdAt);
      allow update, delete: if false; // Reports are immutable
    }
  }
}